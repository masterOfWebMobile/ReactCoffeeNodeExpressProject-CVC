// Generated by CoffeeScript 1.9.3
(function() {
  var React, ReactCanvas, _, canvasFactories, common, dom,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  _ = require('lodash');

  React = require('react');

  ReactCanvas = null;

  dom = React.DOM;

  common = require('./common');

  canvasFactories = {
    renderText: function(text, fontSize, width, height, style) {
      var dims, ff;
      ff = this.FontFace('Avenir Next Condensed, Helvetica, sans-serif', null, {
        weight: (style != null ? style.fontWeight : void 0) || 400
      });
      dims = this.measureText(text, width, ff, fontSize, height);
      style = _.merge({}, {
        top: 0,
        left: style.textAlign === 'center' ? width / 2 - dims.width / 2 : 0,
        fontFace: ff,
        fontSize: fontSize,
        width: dims.width,
        height: dims.height,
        lineHeight: dims.height
      }, style);
      return this.Text({
        style: style
      }, dims.lines[0].text);
    }
  };

  exports.isWithin = function(x, y, dims) {
    return dims.left < x && (dims.left + dims.width) > x && dims.top < y && (dims.height + dims.top) > y;
  };

  exports.CanvasIcon = common.createFactory({
    componentWillMount: function() {
      this.iconsFontFace = ReactCanvas.FontFace('FontAwesome', null, {
        weight: 'normal'
      });
      return this.dims = ReactCanvas.measureText(this.props.children, 10000, this.iconsFontFace, this.props.style.fontSize, this.props.style.height || this.props.style.fontSize);
    },
    render: function() {
      var style;
      style = _.merge({
        fontFace: this.iconsFontFace,
        left: this.props.style.right != null ? this.props.style.right - this.dims.width : void 0,
        top: this.props.style.bottom != null ? this.props.style.bottom - this.dims.height : void 0,
        height: this.dims.height,
        width: this.dims.width,
        lineHeight: this.dims.height,
        textAlign: 'center'
      }, this.props.style);
      return canvasFactories.Text({
        style: style
      }, this.props.children);
    }
  });

  exports.CanvasListView = common.createFactory({
    componentDidMount: function() {
      var component, def, notElements;
      if (ReactCanvas == null) {
        ReactCanvas = require('react-canvas');
        notElements = ['measureText', 'FontFace'];
        for (component in ReactCanvas) {
          if (!hasProp.call(ReactCanvas, component)) continue;
          def = ReactCanvas[component];
          if (indexOf.call(notElements, component) >= 0) {
            canvasFactories[component] = def;
          } else {
            canvasFactories[component] = React.createFactory(def);
          }
        }
      }
      $('html').addClass('no-scroll');
      this.setState({
        size: this.getContainerBoundingRect()
      });
      this.forceUpdate();
      $(window).on('keydown', this.handleKeyPress);
      $(window).on('resize', this.handleWindowResize);
      return $(window).on('wheel', this.handleWheel);
    },
    componentWillUnmount: function() {
      $(window).off('keydown', this.handleKeyPress);
      $(window).off('resize', this.handleWindowResize);
      $(window).off('wheel', this.handleWheel);
      return $('html').removeClass('no-scroll');
    },
    handleKeyPress: function(e) {
      var pageSize, scrollBy, scrollByMap, smallScroll, totalSize;
      if (this.refs.listView == null) {
        return;
      }
      pageSize = this.refs.listView.scroller.__clientHeight;
      totalSize = this.refs.listView.scroller.getScrollMax().top;
      smallScroll = Math.max(150, this.calculateItemHeight() / 2);
      scrollByMap = {
        40: smallScroll,
        38: -smallScroll,
        34: pageSize,
        33: -pageSize,
        35: totalSize,
        36: -totalSize
      };
      scrollBy = scrollByMap[e.keyCode];
      if (scrollBy == null) {
        return;
      }
      return this.scrollBy(scrollBy);
    },
    handleWindowResize: function() {
      this.updateScrollingDimensions();
      this.setState({
        size: this.getContainerBoundingRect()
      });
      if (this.props.onResize != null) {
        this.props.onResize();
      }
      return this.forceUpdate();
    },
    handleWheel: function(e) {
      var deltaY, ref, smallScroll;
      deltaY = ((ref = e.originalEvent) != null ? ref.deltaY : void 0) || e.deltaY;
      smallScroll = Math.max(150, this.calculateItemHeight() / 2);
      if (deltaY < 0) {
        smallScroll *= -1;
      }
      return this.scrollBy(smallScroll);
    },
    scrollBy: function(scrollBy) {
      var ref, scrollMax, scrollTop;
      if (this.refs.listView == null) {
        return;
      }
      scrollMax = this.refs.listView.scroller.getScrollMax().top;
      scrollTop = ((ref = this.refs.listView.state) != null ? ref.scrollTop : void 0) || 0;
      scrollTop += scrollBy;
      if (scrollTop < 0) {
        scrollTop = 0;
      }
      if (scrollTop > scrollMax) {
        scrollTop = scrollMax;
      }
      return this.refs.listView.scrollTo(0, scrollTop, false);
    },
    handleClick: function(e) {
      var actualY, itemHeight, size;
      size = this.getContainerBoundingRect();
      itemHeight = this.calculateItemHeight();
      actualY = e.clientY + this.refs.listView.state.scrollTop - size.top;
      e.itemIndex = Math.ceil(actualY / itemHeight) - 1;
      e.itemX = e.clientX - size.left;
      e.itemY = actualY - (itemHeight * e.itemIndex);
      e.containerSize = size;
      e.itemHeight = itemHeight;
      if (this.props.onClick != null) {
        return this.props.onClick(e);
      }
    },
    updateScrollingDimensions: function() {
      if (this.refs.listView != null) {
        this.refs.listView.updateScrollingDimensions();
        return this.__cachedItemHeight = null;
      }
    },
    resetScroll: function() {
      if (this.refs.listView != null) {
        return this.refs.listView.scrollTo(0, 0, false);
      }
    },
    componentWillReceiveProps: function(nextProps) {
      return this.updateScrollingDimensions();
    },
    render: function() {
      var emptyContainer, ref, size, style;
      style = {
        position: 'absolute',
        bottom: '0px',
        top: '0px',
        width: '100%',
        overflow: 'hidden',
        cursor: 'pointer'
      };
      emptyContainer = dom.div({
        ref: 'container',
        className: this.props.className,
        style: _.merge(style, this.props.style)
      });
      if (ReactCanvas == null) {
        return emptyContainer;
      }
      if (((ref = this.state) != null ? ref.size : void 0) == null) {
        return emptyContainer;
      }
      size = this.state.size;
      return dom.div({
        id: this.props.id,
        ref: 'container',
        className: this.props.className,
        style: _.merge(style, this.props.style),
        onClick: this.handleClick
      }, canvasFactories.Surface({
        top: 0,
        left: 0,
        width: size.width,
        height: size.height
      }, canvasFactories.ListView({
        ref: 'listView',
        style: {
          top: 0,
          left: 0,
          width: size.width,
          height: size.height
        },
        numberOfItemsGetter: this.calculateNumberOfItems,
        itemHeightGetter: this.calculateItemHeight,
        itemGetter: this.renderItem,
        onScroll: this.props.onScroll,
        scrollTop: this.props.scrollTop
      })));
    },
    getContainerBoundingRect: function() {
      return this.refs.container.getDOMNode().getBoundingClientRect();
    },
    renderItem: function(itemIndex, scrollTop) {
      var size;
      size = this.state.size;
      return this.props.itemGetter(itemIndex, scrollTop, size, canvasFactories);
    },
    calculateItemHeight: function() {
      var size;
      if (this.__cachedItemHeight != null) {
        return this.__cachedItemHeight;
      }
      size = this.state.size;
      return this.__cachedItemHeight = this.props.itemHeightGetter(size);
    },
    calculateNumberOfItems: function() {
      var size;
      size = this.state.size;
      return this.props.numberOfItemsGetter(size);
    }
  });

  exports.CanvasGridView = common.createFactory({
    propTypes: {
      numberOfItems: React.PropTypes.number.isRequired,
      itemSize: React.PropTypes.number.isRequired
    },
    renderLine: function(lineIndex, scrollTop, containerSize, canvas) {
      var i, itemSize, itemsPerLine, line, ref, ref1, results;
      itemSize = this.calculateItemSize(containerSize);
      itemsPerLine = containerSize.width / itemSize;
      line = (function() {
        results = [];
        for (var i = ref = lineIndex * itemsPerLine, ref1 = (lineIndex + 1) * itemsPerLine; ref <= ref1 ? i <= ref1 : i >= ref1; ref <= ref1 ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this);
      return canvas.Group.apply(canvas, [{
        style: {
          top: 0,
          left: 0,
          width: itemSize * itemsPerLine,
          height: itemSize
        }
      }].concat(slice.call(_.flatten(_.map(line, (function(_this) {
        return function(itemIndex, index) {
          var item;
          item = _this.props.renderItem(itemIndex, scrollTop, itemSize, canvas);
          return canvas.Group({
            style: {
              left: 0,
              top: 0,
              width: itemSize,
              height: itemSize,
              translateX: index * itemSize
            }
          }, item);
        };
      })(this))))));
    },
    handleClick: function(e) {
      var column, item, itemSize, itemsPerLine;
      e.preventDefault();
      itemSize = this.calculateItemSize(e.containerSize);
      column = Math.ceil(e.itemX / itemSize) - 1;
      itemsPerLine = e.containerSize.width / itemSize;
      item = itemsPerLine * e.itemIndex + column;
      e.itemX = e.itemX % itemSize;
      e.itemWidth = e.itemHeight;
      if (this.props.onClick != null) {
        return this.props.onClick(item, e);
      }
    },
    componentWillUpdate: function() {
      this.refs.listView.updateScrollingDimensions();
      return this._itemSizeCache = null;
    },
    handleResize: function() {
      this._itemSizeCache = null;
      return this.forceUpdate();
    },
    calculateItemSize: function(containerSize) {
      var itemMinSize, itemsPerLine;
      if (this._itemSizeCache != null) {
        return this._itemSizeCache;
      }
      itemMinSize = this.props.itemMinSize || this.props.itemSize;
      return this._itemSizeCache = containerSize.width > this.props.itemSize ? (itemsPerLine = Math.round(containerSize.width / this.props.itemSize), containerSize.width / itemsPerLine) : containerSize.width <= itemMinSize ? containerSize.width : (itemsPerLine = Math.round(containerSize.width / itemMinSize), containerSize.width / itemsPerLine);
    },
    calculateNumberOfLines: function(containerSize) {
      var itemsPerLine, lines;
      itemsPerLine = containerSize.width / this.calculateItemSize(containerSize);
      lines = Math.ceil(this.props.numberOfItems / itemsPerLine);
      return lines;
    },
    getScrollTop: function() {
      return this.refs.listView.getScrollTop();
    },
    resetScroll: function() {
      return this.refs.listView.resetScroll();
    },
    render: function() {
      return exports.CanvasListView({
        ref: 'listView',
        numberOfItemsGetter: this.calculateNumberOfLines,
        itemHeightGetter: this.calculateItemSize,
        itemGetter: this.renderLine,
        onClick: this.handleClick,
        onResize: this.handleResize,
        scrollTop: this.props.scrollTop,
        style: this.props.style,
        onScroll: this.props.onScroll
      });
    }
  });

}).call(this);

//# sourceMappingURL=canvas.js.map
